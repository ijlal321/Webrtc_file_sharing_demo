// import modules
import * as uiUtils from "./uiUtils.js";
import { DOM } from "./uiUtils.js";
import * as constants from "./constants.js";
import * as ws from "./ws.js";

// set up global variables
let pc; // define a global local peer connection object that contains everything we need to establish a WebRTC connection
let dataChannel; // we will set this up when we create a peer connection
const iceCandidatesGenerated = []; // for learning purposes, we will store all ice candidates generated inside of an array
const iceCandidatesReceivedBuffer = [];

// step 1 (md file reference)
const webRTCConfiguratons = {
    iceServers: [
        {
            urls: [
                "stun:stun.l.google.com:19302",
                "stun:stun2.l.google.com:19302",
                "stun:stun3.l.google.com:19302",
                "stun:stun4.l.google.com:19302",
            ]
        }
    ]
};


export function startWebRTCProces() {
    // define function scoped variables
    let offer; 

    uiUtils.logToCustomConsole('Step 1: create a WebRTC peer connection object by clicking on the first button');
    // add a click event listener on the create PC button
    // step 2 (md file reference)
    DOM.offeror.offerorCreatePcButton.addEventListener("click", () => {
        createPeerConnectionObject(); 
        // ui update
        uiUtils.updateUIButton(DOM.offeror.offerorCreatePcButton, "Step 2: now add the type of data exchange to your PC object");
        // learning purpose: console the localDescription session object
        console.log("Local Description (null): after creating a peer connection: ", pc.localDescription); 
    });

    // step 3 & 4 (md file reference)
    DOM.offeror.offerorAddDataTypeButton.addEventListener("click", () => {
        // create our dataChannel
        createDataChannel(true); 
        uiUtils.updateUIButton(DOM.offeror.offerorAddDataTypeButton, "Now create your WebRTC offer");
        console.log("Your pc object: after creating a data channel", pc);
    }); 

    // step 5 - creating offer (md file reference)
    DOM.offeror.offerorCreateOfferButton.addEventListener("click", async () => {
        offer = await pc.createOffer(); // this is a promise
        uiUtils.logToCustomConsole("Succesfully created an offer - why don't you view it in the console?", constants.myColors.green);
        console.log("Here's your offer: ", offer);
        uiUtils.updateUIButton(DOM.offeror.offerorCreateOfferButton,"You now have to update your local pc object with that offer");
    });

    // step 6 - adding offer to offeror's pc object (md file reference)
    DOM.offeror.offerorSetLocalDescriptionButton.addEventListener("click", async () => {
        await pc.setLocalDescription(offer); 
        uiUtils.updateUIButton(DOM.offeror.offerorSetLocalDescriptionButton, "You must now send your offer to the other peer");
        console.log("Your pc object: after adding your offer to your pc object", pc);
        // ice candidates will now be gathered by the browser
    });

    // step 8 - sending offer to signaling server (md file reference)
    DOM.offeror.offerorSendOfferButton.addEventListener("click", () => {
        ws.sendOffer(offer);
        // update UI
        uiUtils.updateUIButton(DOM.offeror.offerorSendOfferButton, "Offer is sent. Now wait for an answer ...")
    });


}; // End of the WEBRTCPROCESS function

// create a users local peer connection object by invoking the RTCPeerConnection object
function createPeerConnectionObject() {

    pc = new RTCPeerConnection(webRTCConfiguratons); // created a pc object that will handle the entire WebRTC session for this peer
    
    // ### register event listeners

    // #1. listen for WebRTC connection state change event (goal is "connected")
    pc.addEventListener("connectionstatechange", () => {
        console.log("connection state changed to: ", pc.connectionState); 
        if(pc.connectionState === "connected") {
            alert("YOU HAVE DONE IT! A WEBRTC CONNECTION HAS BEEN MADE BETWEEN YOU AND THE OTHER PEER");
            uiUtils.logToCustomConsole(`Connection state changed to: ${pc.connectionState}`, null, true, constants.myColors.green);
            // update UI to allow users to send messages (via the DataChannel) and remove the learning buttons
            uiUtils.updateUiOnSuccessfullConnection();
        }
    });

    // #2. listen for change in the signaling state
    pc.addEventListener("signalingstatechange", () => {
        uiUtils.logToCustomConsole(`Signaling state changed to: ${pc.signalingState}`, null, true, constants.myColors.orange);
    });
    // step 7 - listening for ice candidates (md file reference)
    // #3. listen for ice candidate generation
    pc.addEventListener("icecandidate", (e) => {
        uiUtils.logToCustomConsole(`Ice candidate has been generated by the browser`, null, true, constants.myColors.blue);
        if(e.candidate) {
            console.log("ICE:", e.candidate);
            iceCandidatesGenerated.push(e.candidate);
        }
    });

    // #4. listen for the ice connection property to change value
    // pc.addEventListener("iceconnectionstatechange", () => {
    //     if(pc.iceConnectionState === "disconnected") {
    //         closePeerConnection();
    //     }
    // })

    // return out of this function
    return uiUtils.logToCustomConsole("You've succesfully created a PC object", constants.myColors.green);
}; 

// create a data channel
function createDataChannel(isOfferor) {
    if (isOfferor) {
        // only need to create a data channel once, when an offer is established
        // to mimic UDP type transport on our data channel, set the 'ordered' property to false, and the maxRetransmits to 0
        const dataChannelOptions = {
            ordered: false, 
            maxRetransmits: 0
        };
        dataChannel = pc.createDataChannel("top-secret-chat-room", dataChannelOptions);
        // add event listeners
        registerDataChannelEventListeners();
        uiUtils.logToCustomConsole("Succesfully created a Data Channel and added it to your pc object");
    } else {
        // if this else is executed, we are dealing with the oferree
        // the receiver needs to register a ondatachannel listener
        // this will only fire once a valid webrtc connection has been established
        pc.ondatachannel = (e) => {
            console.log("The ondatachannel event was emitted for PEER2. Here is the event object: ", e);
            dataChannel = e.channel;
            registerDataChannelEventListeners();
            uiUtils.logToCustomConsole("Succesfully registered the ondatachannel event listener on your pc object");
        }
    }
};

function registerDataChannelEventListeners() {
    dataChannel.addEventListener("message", (e) => {
        console.log("message has been received from a Data Channel");
        // first, we need to extract the actual data from the Data Channel
        const msg = e.data; 
        uiUtils.addIncomingMessageToUi(msg);
    });
    dataChannel.addEventListener("close", (e) => {
        // will fire for all users that are listening on this data channel
        console.log("The 'close' event was fired on your data channel object");
    });
    dataChannel.addEventListener("open", (e) => {
        // this will fire when webrtc connection is established. 
        console.log("Data Channel has been opened. You are now ready to send/receive messsages over your Data Channel");
    });
};

export function handleOffer(data) {
    let answer; 

    uiUtils.logToCustomConsole("WebRTC offer ðŸ“¨ received. Create your peer connection object");
    // show the buttons to peer2
    uiUtils.showOffereeButtons(); 
    // steps 13 and 14 (ref md file)
    // add event listeners to the learning buttons
    DOM.offeree.offereeCreatePcButton.addEventListener("click", () => {
        createPeerConnectionObject(); 
        // ui changes
        uiUtils.updateUIButton(DOM.offeree.offereeCreatePcButton, "Next, register an event listener on your pc object, for a data channel");
    });

    // steps 15 and 16 (ref md file)
    DOM.offeree.offereeAddDataTypeButton.addEventListener("click", () => {
        createDataChannel(false); // passing in false, to ensure our logic does not create a new dataChannel object
        // ui changes
        uiUtils.updateUIButton(DOM.offeree.offereeAddDataTypeButton, "Now, you can update your pc object, by setting the remote description");
    });

    // step 17 (set remote description. ref md file)
    DOM.offeree.offereeSetRemoteDescriptionButton.addEventListener("click", async () => {
        await pc.setRemoteDescription(data.offer);
        // ui changes
        uiUtils.updateUIButton(DOM.offeree.offereeSetRemoteDescriptionButton, "Next, create your answer");
    });

    // step 18 (ref md file)
    DOM.offeree.offereeCreateAnswerButton.addEventListener("click", async () => {
        answer = await pc.createAnswer(); 
        uiUtils.logToCustomConsole("Succesfully created an answer. Why don't you view it in the console?", constants.myColors.green);
        console.log("answer: ", answer);
        // ui changes
        uiUtils.updateUIButton(DOM.offeree.offereeCreateAnswerButton, "Update your local description with that answer");
    });
    // step 19 (ref md file)
    DOM.offeree.offereeSetLocalDescriptionButton.addEventListener("click", async () => {
        await pc.setLocalDescription(answer);
         // ui changes
         uiUtils.updateUIButton(DOM.offeree.offereeSetLocalDescriptionButton, "Send your answer to PEER1");
    });

    // step 21 (ref md file)
    DOM.offeree.offereeSendAnswerButton.addEventListener("click", () => {
        ws.sendAnswer(answer);
        // ui changes
        uiUtils.updateUIButton(DOM.offeree.offereeSendAnswerButton, "Answer is sent. Don't forget to send your ice candidates too");
        // show ice button
        DOM.offeree.offereeIceButton.classList.remove("hide");
        DOM.offeree.offereeIceButton.classList.add("show-ice");
    });

    DOM.offeree.offereeIceButton.addEventListener("click", () => {
        ws.sendIceCandidates(iceCandidatesGenerated);
        uiUtils.logToCustomConsole("ice candidates sent");
        uiUtils.logToCustomConsole("ðŸ§ŠðŸ§ŠðŸ§Š waiting to receive ICE candidates from the other side ðŸ§ŠðŸ§ŠðŸ§Š");
        // ui changes
        uiUtils.updateUIButton(DOM.offeree.offereeIceButton, "You are all done. Wait for the other side.");
    });
}; // end of the handleOffer function 

export function handleAnswer(data) {
    uiUtils.logToCustomConsole("answer received. Send your ice candidates to PEER2");
    // show the ice button
    DOM.offeror.offerorIceButton.classList.remove("hide");
    DOM.offeror.offerorIceButton.classList.add("show-ice");

    DOM.offeror.offerorIceButton.addEventListener("click", () => {
        ws.sendIceCandidates(iceCandidatesGenerated);
        // ui changes
        uiUtils.updateUIButton(DOM.offeror.offerorIceButton, "Finally, set your remote description");
        // show the setRemoteDescriptionButton
        DOM.offeror.offerorSetRemoteDescriptionButton.classList.remove("hide");
    });

    DOM.offeror.offerorSetRemoteDescriptionButton.addEventListener("click", async () => {
       await pc.setRemoteDescription(data.answer);
       uiUtils.logToCustomConsole("remote description updated with the answer");

        // finally, add the ice candidates inside the buffer (if any)
        // once remoteDescription is set, you can add ice candidates
        for (const candidate of iceCandidatesReceivedBuffer) {
            await pc.addIceCandidate(candidate);
            uiUtils.logToCustomConsole('Added ice candidate to pc');
        }; 
        iceCandidatesReceivedBuffer.splice(0, iceCandidatesReceivedBuffer.length); // reset buffer
    });


};  // end of the handleAnswer function 

// handle ice candidates received from the signaling server
export function handleIceCandidates(data) {
    if(pc.remoteDescription) {
        try {
            data.candidatesArray.forEach(candidate => {
                pc.addIceCandidate(candidate);
                uiUtils.logToCustomConsole("Added ice candidate to your pc object");
            });
        } catch (error) {
                console.log("Error trying to add an ice candidate to the pc object", error);
        }
    } else {
        // create a temporary buffer
        data.candidatesArray.forEach(candidate => {
            iceCandidatesReceivedBuffer.push(candidate);
            uiUtils.logToCustomConsole("Added ice candidate to your temp buffer");
        })
    }   
}; // end of the handleIceCandidates function

// data channel function to send messages

export function sendMessageUsingDataChannel(message) {
    dataChannel.send(message);
};  

// handle a closure
export function closePeerConnection() {

    // step 1 (optional): close a data channel if it exists
    // if(dataChannel) {
    //     dataChannel.close(); 
    //     dataChannel = null;
    //     console.log("data channel closed");
    // }

    // step 2: close the pc if it exists
    if(pc) {
        pc.close(); // calling this will automatically close all data channels
        pc = null; // ensure we free up memory by setting pc object to null
        dataChannel = null;
        console.log("You have closed your peer connection by calling the 'close()' method");
    }

    console.log("Your pc object after calling closePeerConnection() is : ", pc);
};